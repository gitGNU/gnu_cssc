#! /bin/sh

######################################################################
#                             CAUTION                                #
# When editing this file be aware that it is the focus of /bin/sh    #
# portability problems.  Be very, very careful!  Problems with this  #
# file could cause test cases to succeed when they should fail!      #
######################################################################

# Common function definitions.
. ../common/command-names


## First, find out how to echo without appending a newline,
## and so on.  We end up with three variables:-
#
# ac_n		Leading argument for echo to suppress newline.
# ac_c          Trailing arg for suppressing newline.
# ac_t          (don't know -- I stole this code from Autoconf...)
#
if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null; then
  # Stardent Vistra SVR4 grep lacks -e, says ghazi@caip.rutgers.edu.
  if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null; then
    ac_n= ac_c='
' ac_t='	'
  else
    ac_n=-n ac_c= ac_t=
  fi
else
  ac_n= ac_c='\c' ac_t=
fi

# If "echo -e" generates an error, don't do that.  Hey, at least
# /dev/null works!
if (echo -e) >/dev/null 2>&1
then
    if (echo -e) | sed s/-e/xe/ | grep xe >/dev/null
    then
	ac_e=''
    else
	ac_e='-e'
    fi
fi



# Function for echoing without a newline, with escape chars enabled.
echo_nonl () {
echo $ac_n $ac_e "$@$ac_c" ;
}


expect_fail=false

# Call fail when a test failed.
fail () { 
name=`basename $0`
if ${expect_fail:-false}
then
	echo XFAIL $name $* 
	# but don't exit...
else
	echo FAIL $name $* ; exit 2; 
fi ;
}


# Call success when a test succeeded.
success () { 
name=`basename $0`
if ${expect_fail:-false}
then
	echo XPASS $name: $* ; exit 0; 
else
	echo PASS $name:  $* ; exit 0; 
fi ;
}

# Call miscarry wen a test could not be completed.
miscarry () { echo `basename $0`: Test could not be completed; exit 1 ; }


remove () { rm -rf $* || miscarry Could not remove $* ; }

##############
docommand () {
# $1 is the label.  
# $2 is the command to execute.
# $3 is the return value to expect
# $4 is what to expect on stdout
# $5 is what to expect on stderr.
#
# If --silent is specified before the label, no output is notmally made.
#
remove last.command expected.stdout expected.stderr got.stdout got.stderr
label=$1
case $1 in
--silent) silent=true ; shift ; label=$1 ;;
       *) silent=false  ;;
esac
eval "$silent" || echo_nonl "$label..."

shift

echo_nonl $4 > expected.stderr
echo $1 > last.command

echo $1 >> command.log
eval "$1" >got.stdout 2>got.stderr
rv=$?

if test "$2" != "IGNORE"
then
    test $rv -eq $2 || fail "$label: $1: Expected return value $2, got return value $rv"
fi

if test "$3" != "IGNORE"
then
    echo_nonl $3 > expected.stdout
    # diff can fail if the file does not end in newline.
    echo        >>expected.stdout
    echo        >>     got.stdout
    diff expected.stdout got.stdout || fail $label: stdout format error with $1
fi

if test "$4" != "IGNORE"
then
    echo_nonl $4 > expected.stderr
    # diff can fail if the file does not end in newline.
    echo        >>expected.stderr
    echo        >>     got.stderr
    diff expected.stderr got.stderr || fail $label: stderr format error with $1
fi

remove last.command expected.stdout expected.stderr got.stdout got.stderr
eval "$silent" || echo "passed "
true ;
}

#######################
do_output () {
# $1 is the label.
# $2 is the command to execute.
# $3 is the return value to expect
# $4 is a file containing what to expect on stdout.
# $5 is what to expect on stderr.
remove last.command expected.stdout expected.stderr got.stdout got.stderr
label=$1
echo_nonl "$label..."
shift

echo_nonl $4 > expected.stderr
echo $1 > last.command

echo $1 >> command.log
$1 >got.stdout 2>got.stderr
rv=$?

if test "$2" != "IGNORE"
then
    test $rv -eq $2 || fail "$label: $1: Expected return value $2, got return value $rv"
fi

if test "$3" != "IGNORE"
then
    diff $3 got.stdout || fail $label: stdout format error with $1
fi

if test "$4" != "IGNORE"
then
    echo_nonl $4 > expected.stderr
    # diff can fail if the file does not end in newline.
    echo        >>expected.stderr
    echo        >>     got.stderr
    diff expected.stderr got.stderr || fail $label: stderr format error with $1
fi

remove last.command expected.stdout expected.stderr got.stdout got.stderr
echo "passed "
true ;
}
